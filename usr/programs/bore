local ignoreSlots = {}
local headingOrder = {}
  headingOrder[1] = vector.new(1,0,0)
  headingOrder[2] = vector.new(0,0,1)
  headingOrder[3] = vector.new(-1,0,0)
  headingOrder[4] = vector.new(0,0,-1)

local args = {...}
local slotString = args[1]
local depth = args[2]

for i = 1,#slotString
do
  ignoreSlots[i] = tonumber(slotString:sub(i,i), 16)
end

-- check if block is wanted
local function isDesired(compareFunc, detectFunc)
  if not detectFunc()
  then
    return false
  end
    
  for i,slot in pairs(ignoreSlots)
  do
    turtle.select(slot)
    if compareFunc()
    then
      return false
    end
  end
  return true
end

local function bruteDig(moveFunc, digFunc)
  while not moveFunc()
  do
    digFunc()
  end
end

-- executed at every block
function doBlock(recurseDepth)
  -- find the recursion depth of the call
  local rDepth = recurseDepth or 0

  -- save location
  local position = location.getPos()
    
  -- check for useful block in all flat directions
  for i = 1,4
  do
  
    move.turnTo(headingOrder[i])
    if isDesired(turtle.compare, turtle.detect)
    then
      -- begin recursive seeking of ore
      bruteDig(bucket.forward, turtle.dig)
      doBlock(rDepth + 1)
      move.digTo(position)
    end
  
  end
  
  -- check for useful block up
  if isDesired(turtle.compareUp, turtle.detectUp)
  then
    bruteDig(bucket.up, turtle.digUp)
    doBlock(rDepth + 1)
    move.digTo(position)
  end
  
  -- check for useful block down if not first call
  if (rDepth ~= 0) and (isDesired(turtle.compareDown, turtle.detectDown))
  then
    turtle.digDown()
    if bucket.down() -- will fail on bedrock
    then
      doBlock(rDepth + 1)
      move.digTo(position)
    end
  end
  
  -- return to initial position
  -- initial position should be in straight line
  move.digTo(position)
end

-- dig down to depth
local start = location.getPos()

for i = 1,depth
do
  while not turtle.down()
  do
    turtle.digDown()
  end
  
  -- execute per block function
  doBlock()
end

-- return to start
move.digTo(start)
